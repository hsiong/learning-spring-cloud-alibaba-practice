<link rel="stylesheet" type="text/css" href="style.css">

# spring-cloud-alibaba-base
spring cloud alibaba learning

# spring-cloud-alibaba-base
spring cloud alibaba learning

# 第一章 微服务介绍
## 1.1 系统架构演变
单体应用架构--->垂直应用架构--->分布 式架构--->SOA(资源调度和治理中心)架构--->微服务架构--->Service Mesh(服务网格化)  
### 1.1.1 单体应用架构
互联网早期，一般的网站应用流量较小，只需一个应用，将所有功能代码都部署在一起就可以，这样可以减少开发、部署和维护的成本。   

![image](https://user-images.githubusercontent.com/37357447/148877457-e20d81ea-4bd5-4fa0-92e1-5678b69eef8f.png)

+ 优点：
    + 项目架构简单，小型项目的话，开发成本低
    + 项目部署在一个节点上，维护方便  

+ 缺点：
    + 全部功能集成在一个工程中，对于大型项目来讲不易开发和维护
    + 项目模块之间紧密耦合，单点容错率低
    + 无法针对不同模块进行针对性优化和水平扩展
### 1.1.2 垂直应用架构
随着访问量的逐渐增大，单一应用很难应付比较大的访问量。  
这时候需要将原来的一个应用拆成互不相干的几个应用，以提升效率。  
这样拆分完毕之后，一旦用户访问量变大，只需要增加系统的节点就可以了，而无需额外部署。  

![image](https://user-images.githubusercontent.com/37357447/148905888-9da0a5d0-9ce4-40ec-aadd-654f4807bc9f.png)

+ 优点：
    + 系统拆分实现了流量分担，解决了并发问题，而且可以针对不同模块进行优化和水平扩展 一个系统的问题不会影响到其他系统，提高容错率
+ 缺点：
    + 系统之间相互独立，无法进行相互调用
    + 系统之间相互独立，会有重复的开发任务

### 1.1.3 分布式架构
当垂直应用越来越多，重复的业务代码就会越来越多。这时候，我们就思考可不可以将重复的代码抽取出来，做成统一的业务层作为独立的服务，然后由前端控制层调用不同的业务层服务呢？ 
这就产生了新的分布式系统架构。它将把工程拆分成<b style='color:red'>表现层</b>和<b style='color:red'>服务层</b>两个部分，服务层中包含业务逻辑。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。  

![image](https://user-images.githubusercontent.com/37357447/148906950-7bd61a3d-1a7c-4a47-891a-8f9f23e11835.png)

+ 优点:
    + 使用注册中心解决了服务间调用关系的自动调节
+ 缺点:
    + 服务间会有依赖关系，一旦某个环节出错会影响较大(服务雪崩)(因为所有服务都部署在同一个服务层上, 并且具有上下游关系)
    + 服务关心复杂，运维、测试部署困难

### 1.1.5 微服务架构
微服务架构在某种程度上是面向服务的架构SOA继续发展的下一步，它更加强调服务的"彻底拆分"，拆分成更小的服务，每个服务都是一个可以独立运行的项目。  

![image](https://user-images.githubusercontent.com/37357447/148908164-33024b85-cf76-405e-93a7-0cc3f17e385c.png)

+ 优点：
    + 服务原子化拆分，独立打包、部署和升级，保证每个微服务清晰的任务划分，利于扩展微服务之间采用Restful等轻量级http协议相互调用
+ 缺点：
    + 分布式系统开发的技术成本高（容错、分布式事务等）

## 1.2 微服务架构介绍
### 1.2.1 引入
在微服务化后, 伴随<b style='color:red'>服务划分粒度</b>越来越细, 我们也由原先的单体应用, 逐步转变成了多个微服务构成的服务集群, 那么, 势必会出现以下问题, 以及目前主流的解决思路。
<div class='table-center'>

|问题|解决思路|解决办法|
|:-:|:-:|:-:|
|如何管理他们?|服务治理 注册中心[服务注册 发现 剔除]|nacos|
|他们之间如何通讯?|restful rpc||
|客户端怎么访问他们?|网关||
|一旦出现问题，应该如何自处理?|服务容错||
|一旦出现问题，应该如何排错?|链路追踪||
|伴随新的架构体系，应如何架构设计?|事务驱动 领域驱动||  
</div>

![image](https://user-images.githubusercontent.com/37357447/148911880-67edd711-a1cb-4a5d-b8e9-546038b48fa0.png)

### 1.2.2 常用概念
#### 1.2.2.1 服务治理
服务治理就是进行服务的自动化管理，其核心是服务的自动注册与发现。  
+ <b style='color:red'>服务注册</b>：服务实例将自身服务信息注册到注册中心。  
+ <b style='color:red'>服务发现</b>：服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务。  
+ <b style='color:red'>服务剔除</b>：服务注册中心将出问题的服务自动剔除到可用列表之外，使其不会被调用到。  

![image](https://user-images.githubusercontent.com/37357447/148913750-13ef5a3a-bfaa-4dd3-b824-e39b49f16276.png)

#### 1.2.2.2 服务调用
在微服务架构中，通常存在多个服务之间的远程调用的需求。目前主流的远程调用技术有基于HTTP的<b style='color:red'>RESTFUL接口</b>以及基于TCP的<b style='color:red'>RPC协议</b>。一般来说, RESTFUL接口即可满足我们大多数开发需求, 配置和适用上也更方便、灵活。
+ REST(Representational State Transfer)  
这是一种HTTP调用的格式，更标准，更通用，无论哪种语言都支持http协议
+ RPC(Remote Promote Call)  
一种进程间通信方式。允许像调用本地服务一样调用远程服务。RPC框架的主要目标就是让远程服务调用更简单、透明。  
RPC框架负责屏蔽底层的传输方式、序列化方式和通信细节。开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节和调用过程。  
<div class='table-center'>

|比较项|RESTFUL|RPC|
|:-:|:-:|:-:|
|通讯协议|HTTP|常用TCP, 亦支持UDP HTTP|
|性能|较低|较高|
|灵活度|高|低|
|应用|微服务|SOA|
</div>

#### 1.2.2.3 服务网关
随着微服务的不断增多，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求, 如果让客户端直接与各个微服务通信可能出现：
+ 客户端需要调用不同的url地址，增加难度
+ 在一定的场景下，存在跨域请求的问题                                    
+ 每个微服务都需要进行单独的身份认证  

为了解决这些问题, 我们引入了<b style='color:red'>API网关</b>。  
API网关是将所有API调用统一接入到API网关层，由网关层统一接入和输出。有了网关之后，各个API服务提供团队可以专注于自己的的业务逻辑处理，而API网关更专注于安全、流量、路由等问题。  
一个API网关的基本功能包括：
+ 统一接入
+ 安全防护
+ 协议适配
+ 流量管控
+ 长短链接支持
+ 容错能力

![image](https://user-images.githubusercontent.com/37357447/148919726-5e2e391e-57c0-4398-9813-4796e7532cea.png)






































